# PREP Maker

https://www.prep-maker.site/  
PREP Maker는 구조적 글쓰기를 도와주는 앱입니다. PREP 앱과 함께 P(주장, 주제) - R(이유, 설명) - E(예시) - P(주장, 주제 강조) 순서로 설득력있고 간결한 글을 쓸 수 있습니다.

## 사용법

 <details>
  <summary>로그인 페이지</summary>
  <div markdown="1">

![로그인 페이지](https://user-images.githubusercontent.com/80461702/159209265-baa73dbe-427e-490f-ae31-0c55e7bb9091.png)

1. 로그인을 합니다. 계정이 없으면 회원가입을 합니다.
</div>
</details>

 <details>
  <summary>편집 페이지</summary>
  <div markdown="1">

![편집 페이지](https://user-images.githubusercontent.com/80461702/159209328-dae5e2ea-c01f-4e65-b333-366f276e25a9.png)
![편집 페이지](https://user-images.githubusercontent.com/80461702/159209337-00f274df-b928-415f-9fcd-d6224142c000.png)

2. 새 글을 생성합니다.
3. 블록을 생성합니다.
4. 블록 타입에 맞게 글을 씁니다.
5. 제목을 클릭하면 제목을 수정할 수 있습니다.
6. 블록 삭제 버튼을 눌러 블록을 삭제할 수 있습니다.

7. 블록을 드래그 앤 드롭하여 PREP 순서로 블록을 합체합니다. 문단 검사를 통과하지 못한 블록은 합체가 불가합니다.
8. 블록이 모두 합체되면 완료 버튼을 눌러 검토 페이지로 이동합니다.

9. 로그인을 합니다. 계정이 없으면 회원가입을 합니다.
</div>
</details>

<details>
  <summary>검토 페이지</summary>
  <div markdown="1">
  
![검토 페이지](https://user-images.githubusercontent.com/80461702/159209690-0d7ee104-5e7d-403a-8a48-59b5ad039bb1.png)

9. 검토페이지에서 문단을 클릭하여 문단을 수정할 수 있습니다.
10. 공유버튼을 눌러 다른 사람에게 공유할 수 있는 링크를 복사할 수 있습니다.
</div>
</details>

<details>
  <summary>피드백 페이지</summary>
  <div markdown="1">
  
![피드백 페이지](https://user-images.githubusercontent.com/80461702/159209604-b1c9bd32-f023-47b1-af60-d52a42d889be.png)

11. 공유된 링크를 주소에 붙여넣으면 피드백 페이지가 열립니다.
12. 피드백 페이지에서 문단을 클릭하면 코멘트를 작성할 수 있습니다. 로그인하지 않은 사용자는 로그인 페이지로 이동할 수 있습니다.
13. 코멘트 작성 버튼을 누르면 pending 상태의 코멘트가 생성됩니다.
14. 완료 버튼을 눌러 전송, 취소를 선택할 수 있습니다. 전송 버튼을 누르면 코멘트가 저장됩니다. 취소 버튼을 누르면 pending 상태인 코멘트가 삭제됩니다.
15. 코멘트 작성자는 삭제 버튼을 눌러 작성된 코멘트를 삭제할 수 있습니다.
</div>
</details>

## 프로젝트 기간

📆 2022. 2. 21. ~ 2022. 3. 13. (21일)

- 1주차(2.21. ~ 2.27.)
  - 브레인 스토밍
  - 목업 작성
  - 칸반보드 작성
  - 프로젝트 세팅
- 2주차(2.28. ~ 3.6.)
  - 기능 구현
  - 테스트 코드 작성
- 3주차(3.7. ~ 3.13.)
  - 기능 구현 마무리
  - 테스트 코드 작성
  - 배포

## 기술스택

|    공통    |    Frontend     |  Backend  |
| :--------: | :-------------: | :-------: |
| TypeScript |      React      |  Node.js  |
|    Jest    |      Redux      |  Express  |
|            |      Thunk      |  MongoDB  |
|            | Testing Library |   FxTS    |
|            |                 | Supertest |

## OOP

원활한 유지보수를 위해 객체지향적 코드를 작성하고자 노력했습니다. 프론트엔드의 HttpClient 클래스가 일관된 HTTP 요청 config를 유지할 수 있도록 싱글톤 패턴을 적용하였습니다. 프론트엔드, 백엔드 전반적으로 의존성 주입을 활용하여 모듈간 의존도를 낮추고자 하였습니다.

프론트엔드에서는 api 클래스의 인스턴스를 Redux Thunk의 extraArgument로 주입하였습니다. 프론트엔드에서 api 서비스를 어떻게 분리해야할지 고민이 컸습니다. 그러던 중 [Redux Thunk의 공식문서](https://github.com/reduxjs/redux-thunk)에서 Redux 미들웨어 셋업 시 Thunk의 extraArgument를 사용해 api 서비스를 주입할 수 있다는 내용을 접하게 되었습니다. 이를 이용하면 각 api 클래스 인스턴스를 생성하고 조립하는 코드를 store 모듈에 모아서 관리할 수 있고, 데이터 통신 관련 로직을 Thunk에 응집시킬 수 있기에 api 서비스 계층을 분리하는 방법으로 적합하다는 판단이 들었습니다. 덕분에 api 클래스만 모킹하여 테스트 코드를 더 수월하게 작성할 수 있었습니다.

백엔드에서는 model, service, presenter, controller로 계층을 분리하였습니다. model, service, controller로 분리하는 것이 당초 계획이었으나, 에러 핸들링과 validation 로직을 포함하니 service 모듈이 예상보다 거대해져 모듈 분리의 필요성을 느끼게 됐습니다. 따라서 service 로직에 에러 핸들링과 validation을 더해주는 presenter 계층을 추가하였습니다. 테스트 코드에서는 model 클래스와 동일한 인터페이스를 가진 stub클래스를 활용하여, DB로부터 독립된 빠른 유닛 테스트를 작성할 수 있었습니다.

## 타입스크립트

명시적으로 코드를 작성하고 빠른 디버깅을 통해 버그로부터 안전한 앱을 만들기 위해 타입스크립트를 채택하였습니다. 타입스크립트 덕분에 더 객체지향적인 코드를 작성할 수도 있었습니다. 모듈끼리 인터페이스로 소통함으로서 안정적이면서도 모듈간 의존도가 낮은 앱을 만들 수 있었습니다.

프로젝트가 90% 정도 완성되었을 때 전반적인 앱의 기능과 활용도가 부족하다 판단되어, 기획 단계에서는 없었던 피드백 페이지를 추가하게 되었습니다. 이로 인해 백엔드 스키마를 수정해야 했습니다. 프로젝트가 많이 진행된 시점에 스키마를 수정해야한다는 점이 부담이었지만, 타입스크립트 덕분에 비교적 적은 수정사항으로 안정적인 기능 확장이 가능했습니다.

## FxTS

제너레이터를 활용한 지연 평가를 시도해보고, 함수형 프로그래밍으로 가독성을 개선시켜보고자 FxTS 라이브러리를 도입했습니다.

그런데 프론트엔드에서는 알아내지 못한 타입스크립트 컴파일 에러로 FxTS를 아예 활용하지 못했습니다. 원인을 밝혀 해결했다면 FxTS에 기여할 수 있었을텐데 그러지 못해 아쉬웠습니다. 백엔드에서도 DB에 동시에 여러 쿼리를 보내는 메소드를 작성할 때, FxTS를 활용한 것보다 Promise.all을 활용한 것이 약 50ms 빨랐기에 FxTS로 작성한 로직을 Promise.all로 수정해야 했습니다.

하지만 pipe 함수를 활용한 선언적 표현으로 가독성을 개선시킬 수 있다는 점은 매우 만족스러웠습니다. 특히 백엔드에서 에러를 처리할 때 try catch 구문을 FxTS의 pipe 함수와 catchError라는 유틸함수로 대체하여 전반적으로 가독성을 개선시킨 점이 가장 만족스럽습니다.
