# PREP Maker

https://www.prep-maker.site/  
PREP Maker는 구조적 글쓰기를 도와주는 앱입니다. PREP 앱과 함께 P(주장, 주제) - R(이유, 설명) - E(예시) - P(주장, 주제 강조) 순서로 설득력있고 간결한 글을 쓸 수 있습니다.

**PREP Maker는 로그인 후 이용 가능합니다.**  
테스트용 이메일: test@email.com  
테스트용 비밀번호: test1234

## 사용법

 <details>
  <summary>로그인 페이지</summary>
  <div markdown="1">

![로그인 페이지](https://user-images.githubusercontent.com/80461702/159209265-baa73dbe-427e-490f-ae31-0c55e7bb9091.png)

1. 로그인을 합니다. 계정이 없으면 회원가입을 합니다.
</div>
</details>

 <details>
  <summary>편집 페이지</summary>
  <div markdown="1">

![편집 페이지](https://user-images.githubusercontent.com/80461702/159209328-dae5e2ea-c01f-4e65-b333-366f276e25a9.png)
![편집 페이지](https://user-images.githubusercontent.com/80461702/159209337-00f274df-b928-415f-9fcd-d6224142c000.png)

2. 새 글을 생성합니다.
3. 블록을 생성합니다.
4. 블록 타입에 맞게 글을 씁니다.
5. 제목을 클릭하면 제목을 수정할 수 있습니다.
6. 블록 삭제 버튼을 눌러 블록을 삭제할 수 있습니다.

7. 블록을 드래그 앤 드롭하여 PREP 순서로 블록을 합체합니다. 문단 검사를 통과하지 못한 블록은 합체가 불가합니다.
8. 블록이 모두 합체되면 완료 버튼을 눌러 검토 페이지로 이동합니다.

9. 로그인을 합니다. 계정이 없으면 회원가입을 합니다.
</div>
</details>

<details>
  <summary>검토 페이지</summary>
  <div markdown="1">
  
![검토 페이지](https://user-images.githubusercontent.com/80461702/159209690-0d7ee104-5e7d-403a-8a48-59b5ad039bb1.png)

9. 검토페이지에서 문단을 클릭하여 문단을 수정할 수 있습니다.
10. 공유버튼을 눌러 다른 사람에게 공유할 수 있는 링크를 복사할 수 있습니다.
</div>
</details>

<details>
  <summary>피드백 페이지</summary>
  <div markdown="1">
  
![피드백 페이지](https://user-images.githubusercontent.com/80461702/159209604-b1c9bd32-f023-47b1-af60-d52a42d889be.png)

11. 공유된 링크를 주소에 붙여넣으면 피드백 페이지가 열립니다.
12. 피드백 페이지에서 문단을 클릭하면 코멘트를 작성할 수 있습니다. 로그인하지 않은 사용자는 로그인 페이지로 이동할 수 있습니다.
13. 코멘트 작성 버튼을 누르면 pending 상태의 코멘트가 생성됩니다.
14. 완료 버튼을 눌러 전송, 취소를 선택할 수 있습니다. 전송 버튼을 누르면 코멘트가 저장됩니다. 취소 버튼을 누르면 pending 상태인 코멘트가 삭제됩니다.
15. 코멘트 작성자는 삭제 버튼을 눌러 작성된 코멘트를 삭제할 수 있습니다.
</div>
</details>

## 프로젝트 기간

📆 2022. 2. 21. ~ 2022. 3. 13. (21일)

- 1주차(2.21. ~ 2.27.)
  - 브레인 스토밍
  - 목업 작성
  - 칸반보드 작성
  - 프로젝트 세팅
- 2주차(2.28. ~ 3.6.)
  - 기능 구현
  - 테스트 코드 작성
- 3주차(3.7. ~ 3.13.)
  - 기능 구현 마무리
  - 테스트 코드 작성
  - 배포

## 기술스택

|    공통    |    Frontend     |  Backend  |
| :--------: | :-------------: | :-------: |
| TypeScript |      React      |  Node.js  |
|    Jest    |      Redux      |  Express  |
|            |      Thunk      |  MongoDB  |
|            | Testing Library |   FxTS    |
|            |                 | Supertest |

## OOP

원활한 유지보수를 위해 객체지향적 코드를 작성하고자 노력했습니다. 프론트엔드, 백엔드 전반적으로 의존성 주입을 활용하여 모듈간 의존도를 낮추고자 하였습니다.

프론트엔드에서는 api 클래스의 인스턴스를 Redux Thunk의 extraArgument로 주입하였습니다. 프론트엔드에서 api 서비스를 어떻게 분리해야할지 고민이 컸습니다. 그러던 중 [Redux Thunk의 공식문서](https://github.com/reduxjs/redux-thunk)에서 Redux 미들웨어 셋업 시 Thunk의 extraArgument를 사용해 api 서비스를 주입할 수 있다는 내용을 접하게 되었습니다. 이를 이용하면 각 api 클래스 인스턴스를 생성하고 조립하는 코드를 store 모듈에 모아서 관리할 수 있고, 데이터 통신 관련 로직을 Thunk에 응집시킬 수 있기에 api 서비스 계층을 분리하는 방법으로 적합하다는 판단이 들었습니다. 덕분에 api 클래스만 모킹하여 테스트 코드를 더 수월하게 작성할 수 있었습니다.

백엔드에서는 model, service, presenter, controller로 계층을 분리하였습니다. DB에 쿼리를 보내는 model, 핵심 로직을 담은 service, HTTP 요청을 받고 응답하는 controller로 분리하는 것이 당초 계획이었으나, 에러 핸들링과 validation을 포함하니 service 모듈이 예상보다 거대해져 모듈 분리의 필요성을 느끼게 됐습니다. 따라서 service 로직에 에러 핸들링과 validation을 더해주는 presenter 계층을 추가하였습니다.

## 타입스크립트

명시적으로 코드를 작성하고 빠른 디버깅을 통해 버그로부터 안전한 앱을 만들기 위해 타입스크립트를 채택하였습니다. 타입스크립트 덕분에 더 객체지향적인 코드를 작성할 수도 있었습니다. 모듈끼리 인터페이스로 소통함으로서 안정적이면서도 모듈간 의존도가 낮은 앱을 만들 수 있었습니다.

타입스크립트로 인해 겪은 어려움도 물론 존재했습니다. 첫째로, 초기 환경 세팅에 시간을 많이 할애해야했습니다. 타입스크립트 config, 트랜스파일 스크립트에 대해 익히고 적용해야 했기에 프로젝트 초기 진행 속도가 느렸습니다. 둘째로, 전반적인 코드의 타이핑 양이 많아졌습니다. 대부분의 데이터에 타입을 명시해야 했기에 같은 함수를 구현하더라도 자바스크립트 환경보다 더 많은 코드를 타이핑 해야했습니다.

타입스크립트의 장점은 프로젝트 후반부에 실감하게 되었습니다. 프로젝트가 90% 정도 완성되었을 때 전반적인 앱의 기능과 활용도가 부족하다 판단되어, 기획 단계에서는 없었던 피드백 페이지를 추가하게 되었습니다. 이로 인해 백엔드 스키마를 수정해야 했습니다. 프로젝트가 많이 진행된 시점에 스키마를 수정해야한다는 점이 부담이었지만, 타입스크립트 덕분에 비교적 적은 수정사항으로 안정적으로 기능을 확장할 수 있었습니다.

## 테스트

추후 리팩토링, 기능 확장 등이 필요할 때 기존 코드에 오류를 발생시키지 않으면서 안전하게 수정할 수 있도록 테스트 코드를 작성하였습니다. 테스트 코드를 고려하지 않고 기능을 구현하다가 테스트 코드를 쓸 때 많은 어려움을 겪었던 경험이 있기에, 기능 구현 단계에서 부터 테스트 코드를 염두에 두며 코드를 작성했습니다.

프론트엔드에서는 Testing Library를 활용하여 구체적인 구현 사항보단 실제 작동 내용을 테스트하고자 하였습니다. 일부 컴포넌트에 대한 단위 테스트를 수행하고, App 컴포넌트를 테스트함으로서 통합테스트를 수행하였습니다. 백엔드에서는 model 클래스와 동일한 인터페이스를 가진 stub클래스를 활용하여 DB로부터 독립된 빠른 단위 테스트를 작성할 수 있었습니다. 그리고 통합테스트에선 테스트용 DB 콜렉션을 사용하고, 테스트가 끝난 후에 테스트용 DB 콜렉션을 클린업 하도록 테스트 환경을 설정하여 완결성 있는 통합테스트를 수행하고자 하였습니다.
